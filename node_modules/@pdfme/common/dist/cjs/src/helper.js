"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkGenerateProps = exports.checkDesignerProps = exports.checkPreviewProps = exports.checkUIProps = exports.checkTemplate = exports.checkUIOptions = exports.checkInputs = exports.checkPlugins = exports.checkFont = exports.b64toUint8Array = exports.getB64BasePdf = exports.pt2px = exports.pt2mm = exports.mm2pt = exports.getDefaultFont = exports.getFallbackFontName = void 0;
const zod_1 = require("zod");
const buffer_1 = require("buffer");
const schema_1 = require("./schema");
const constants_1 = require("./constants");
const uniq = (array) => Array.from(new Set(array));
const getFallbackFontName = (font) => {
    const initial = '';
    const fallbackFontName = Object.entries(font).reduce((acc, cur) => {
        const [fontName, fontValue] = cur;
        return !acc && fontValue.fallback ? fontName : acc;
    }, initial);
    if (fallbackFontName === initial) {
        throw Error(`[@pdfme/common] fallback flag is not found in font. true fallback flag must be only one.`);
    }
    return fallbackFontName;
};
exports.getFallbackFontName = getFallbackFontName;
const getDefaultFont = () => ({
    [constants_1.DEFAULT_FONT_NAME]: { data: (0, exports.b64toUint8Array)(constants_1.DEFAULT_FONT_VALUE), fallback: true },
});
exports.getDefaultFont = getDefaultFont;
const mm2pt = (mm) => {
    return parseFloat(String(mm)) * constants_1.MM_TO_PT_RATIO;
};
exports.mm2pt = mm2pt;
const pt2mm = (pt) => {
    return pt * constants_1.PT_TO_MM_RATIO;
};
exports.pt2mm = pt2mm;
const pt2px = (pt) => {
    return pt * constants_1.PT_TO_PX_RATIO;
};
exports.pt2px = pt2px;
const blob2Base64Pdf = (blob) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.result.startsWith('data:application/pdf;')) {
                resolve(reader.result);
            }
            else {
                reject(Error('[@pdfme/common] template.basePdf must be pdf data.'));
            }
        };
        reader.readAsDataURL(blob);
    });
};
const getB64BasePdf = (basePdf) => {
    const needFetchFromNetwork = typeof basePdf === 'string' && !basePdf.startsWith('data:application/pdf;');
    if (needFetchFromNetwork && typeof window !== 'undefined') {
        return fetch(basePdf)
            .then((res) => res.blob())
            .then(blob2Base64Pdf)
            .catch((e) => {
            throw e;
        });
    }
    return basePdf;
};
exports.getB64BasePdf = getB64BasePdf;
const getByteString = (base64) => buffer_1.Buffer.from(base64, 'base64').toString('binary');
const b64toUint8Array = (base64) => {
    const data = base64.split(';base64,')[1] ? base64.split(';base64,')[1] : base64;
    const byteString = getByteString(data);
    const unit8arr = new Uint8Array(byteString.length);
    for (let i = 0; i < byteString.length; i += 1) {
        unit8arr[i] = byteString.charCodeAt(i);
    }
    return unit8arr;
};
exports.b64toUint8Array = b64toUint8Array;
const getFontNamesInSchemas = (schemas) => uniq(schemas
    .map((s) => Object.values(s).map((v) => { var _a; return (_a = v.fontName) !== null && _a !== void 0 ? _a : ''; }))
    .reduce((acc, cur) => acc.concat(cur), [])
    .filter(Boolean));
const checkFont = (arg) => {
    const { font, template: { schemas }, } = arg;
    const fontValues = Object.values(font);
    const fallbackFontNum = fontValues.reduce((acc, cur) => (cur.fallback ? acc + 1 : acc), 0);
    if (fallbackFontNum === 0) {
        throw Error(`[@pdfme/common] fallback flag is not found in font. true fallback flag must be only one.
Check this document: https://pdfme.com/docs/custom-fonts#about-font-type`);
    }
    if (fallbackFontNum > 1) {
        throw Error(`[@pdfme/common] ${fallbackFontNum} fallback flags found in font. true fallback flag must be only one.
Check this document: https://pdfme.com/docs/custom-fonts#about-font-type`);
    }
    const fontNamesInSchemas = getFontNamesInSchemas(schemas);
    const fontNames = Object.keys(font);
    if (fontNamesInSchemas.some((f) => !fontNames.includes(f))) {
        throw Error(`[@pdfme/common] ${fontNamesInSchemas
            .filter((f) => !fontNames.includes(f))
            .join()} of template.schemas is not found in font.
Check this document: https://pdfme.com/docs/custom-fonts`);
    }
};
exports.checkFont = checkFont;
const checkPlugins = (arg) => {
    const { plugins, template: { schemas }, } = arg;
    const allSchemaTypes = uniq(schemas.map((s) => Object.values(s).map((v) => v.type)).flat());
    const pluginsSchemaTypes = Object.values(plugins).map((p) => p === null || p === void 0 ? void 0 : p.propPanel.defaultSchema.type);
    if (allSchemaTypes.some((s) => !pluginsSchemaTypes.includes(s))) {
        throw Error(`[@pdfme/common] ${allSchemaTypes
            .filter((s) => !pluginsSchemaTypes.includes(s))
            .join()} of template.schemas is not found in plugins.`);
    }
};
exports.checkPlugins = checkPlugins;
const checkProps = (data, zodSchema) => {
    try {
        zodSchema.parse(data);
    }
    catch (e) {
        if (e instanceof zod_1.z.ZodError) {
            const messages = e.issues.map((issue) => `ERROR POSITION: ${issue.path.join('.')}
ERROR MESSAGE: ${issue.message}
--------------------------`);
            const message = messages.join('\n');
            throw Error(`[@pdfme/common] Invalid argument:
--------------------------
${message}`);
        }
    }
    // Check fon if template and options exist
    if (data && typeof data === 'object' && 'template' in data && 'options' in data) {
        const { template, options } = data;
        if (options && options.font) {
            (0, exports.checkFont)({ font: options.font, template });
        }
    }
    // Check plugins if template and plugins exist
    if (data && typeof data === 'object' && 'template' in data && 'plugins' in data) {
        const { template, plugins } = data;
        if (plugins) {
            (0, exports.checkPlugins)({ plugins, template });
        }
    }
};
const checkInputs = (data) => checkProps(data, schema_1.Inputs);
exports.checkInputs = checkInputs;
const checkUIOptions = (data) => checkProps(data, schema_1.UIOptions);
exports.checkUIOptions = checkUIOptions;
const checkTemplate = (data) => checkProps(data, schema_1.Template);
exports.checkTemplate = checkTemplate;
const checkUIProps = (data) => checkProps(data, schema_1.UIProps);
exports.checkUIProps = checkUIProps;
const checkPreviewProps = (data) => checkProps(data, schema_1.PreviewProps);
exports.checkPreviewProps = checkPreviewProps;
const checkDesignerProps = (data) => checkProps(data, schema_1.DesignerProps);
exports.checkDesignerProps = checkDesignerProps;
const checkGenerateProps = (data) => checkProps(data, schema_1.GenerateProps);
exports.checkGenerateProps = checkGenerateProps;
//# sourceMappingURL=helper.js.map